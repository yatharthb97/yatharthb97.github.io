[{"content":"Welcome to my website! Here, I post about stuff I like and the things I do. I { read, code, think, analyse, and solve } in all permutations. This website cum blog is an attempt to include writing in this set. Below is a short overview of the website.\nprojects: where I post about my scientific and coding projects. publications: lists all the articles I have written and published somewhere. blog: where I will post articles and notes on various themes. gallery: has some cool pictures of me and my work. about me: an overview of my interests \u0026amp; qualifications. collaborate: has a list of projects for which collaborators are required. This website is still being actively developed and is broken at a few places.\nPlease let me know what you think about this website and how I can improve it. You can connect through the various social media links on the home page.\nFor credits and source code, you can visit here.\nMeanwhile the world in which we exist has other aims. But it will pass away, burned up in the fire of its own hot passions, and from its ashes will spring a new and younger world, full of fresh hope, with the light of morning in its eyes.\nBertrand Russell ","permalink":"https://yatharthb97.github.io/blog/welcome/","summary":"Welcome to my website! Here, I post about stuff I like and the things I do. I { read, code, think, analyse, and solve } in all permutations. This website cum blog is an attempt to include writing in this set. Below is a short overview of the website.\nprojects: where I post about my scientific and coding projects. publications: lists all the articles I have written and published somewhere. blog: where I will post articles and notes on various themes.","title":"Welcome!"},{"content":"Safe and accurate parsinggit status of time literals (values + units) is both common and crucial requirement. While C++ has a mechanism through STL chrono, such a functionality is absent in python (as per my information).\nLibrary: GitHub Gist.\nWhat is a time-literal? Just to be clear, time literal here means anything of this form : 5ns, 4min, 15.5ms. It is a numeric value (float) followed by alphabetic constants that indicate special treatment of the alpha-numeric string constant. It is similar to the use of b while declaring bytes or using x while defining a hexadecimal integer:\nbinary = 0b10000 hexadecimal = 0x12f Since python does not natively support time-literals, it can be implemented by using python strings. Here is my attempt to do the same, and while we are at it, implement some additional features as well.\nHere is a rundown of the library: A value_pair is an entity of the following form: [float, TmLiteral]. The container should be a list. The first is the absolute numeric value and the second quantity is the units, which is represented by the TmLiteral object. value_pair is fundamental to this library, since strings are parsed into value pairs. All inter-conversions also apply to value pairs. For performing such operations, the literal must first be converted into a value_pair by using the TmParser object. To verify if the given entity is a valid value-pair:\nfrom tmliteral import * IsValuePair([4.2, FindTmL(\u0026#34;seconds\u0026#34;)]) #-\u0026gt; returns True IsValuePair([4.2, \u0026#34;seconds\u0026#34;]) #-\u0026gt; returns False Print all available pre-defined literals:\nimport tmliteral.time_table for tml in tmliteral.time_table: print(tml.abbr, \u0026#39; : \u0026#39;, tml) Output:\nxxx : invalid time value s : second Ys : yottasecond Zs : zettasecond Es : exasecond Ps : petasecond Ts : terasecond Gs : gigasecond Ms : megasecond ks : kilosecond hs : hectosecond das : decasecond ds : decisecond cs : centisecond ms : millisecond us : microsecond ns : nanosecond ps : picosecond fs : femtosecond as : attosecond zs : zeptosecond ys : yoctosecond min : minute h : hour d : day week : week year : calender year leapyear : calender leap year gregyear : gregorian calendar year julianyear : julian astronomical year Create a user defined literal or find a pre-defined literal:\n# Simulation unit which is equivalent to microseconds. sim_time = TmL(\u0026#34;sim\u0026#34;, -6, simulation unit) # TmL(abbr, exp, name, mul_factor=1.0) # Get a pre-defined time unit ms = FindTmL(\u0026#34;ms\u0026#34;) also_ms = FindTmL(\u0026#34;millisecond\u0026#34;) Parsing time literals from strings can be done by creating a parser object:\nparser = TmParser() parser.add_literal(sim_time) tm1 = parser.parse(\u0026#34;4.2fs\u0026#34;) # Out→ [4.2, \u0026lt; TmLiteral : femtosecond \u0026gt;] tm2 = parser[\u0026#34;4.2fs\u0026#34;] # Same tm_sim = parser[\u0026#34;5 sim\u0026#34;] # Out→ [5.0, \u0026lt; TmLiteral : simulation time \u0026gt;] Conversions between units (casting) can be handled by creating a cast object:\nns_cast = TmCast.Find(\u0026#34;ns\u0026#34;) # Make a nano-second cast time = parser[\u0026#34;5 ms\u0026#34;] ns_time = ns_cast.cast(time) # Returns 5000 ns_time2 = ns_cast[tm2] # Equivalent to `cast` member function. Using the TmAutoScale object, appropriate units can be selected automatically. The option tmparser in the initializer can be used to pass a custom TmParser object. The auto-scale object inherits the literal order of the parser object in the \u0026ldquo;default\u0026rdquo; mode. If this option is not specified, the auto-scaler constructs a new generic TmParser object.\nThis module is extremely useful with timing of processes and converts arbitrary time values in seconds (or nanoseconds) to more \u0026ldquo;human readable\u0026rdquo; units. The object can be constructed in a variety of mode:\n\u0026ldquo;default\u0026rdquo; : Does not modify the preference of literals which is inherited from a parser object. prefer_clock_units\u0026quot; : Prefers clock units over SI. clock units are [\u0026ldquo;second\u0026rdquo;, \u0026ldquo;minute\u0026rdquo;, \u0026ldquo;hour\u0026rdquo;, \u0026ldquo;day\u0026rdquo;, \u0026ldquo;week\u0026rdquo;, \u0026ldquo;calender year\u0026rdquo;] \u0026ldquo;prefer_SI_units\u0026rdquo; : Prefers SI units over clock units. \u0026ldquo;clock\u0026rdquo; : Only uses clock units \u0026ldquo;SI\u0026rdquo; : Only uses SI units \u0026ldquo;extended_process_timing\u0026rdquo; : Uses [\u0026ldquo;nanoseconds\u0026rdquo;, \u0026ldquo;microseconds\u0026rdquo;, \u0026ldquo;milliseconds\u0026rdquo;] + clock units. This is useful for timing of processes which requires \u0026ldquo;human-comprehensible units\u0026rdquo; on a power scale. tauto = TmAutoScale(mode=\u0026#34;prefer_clock_units\u0026#34;) tauto.scale(parser[\u0026#34;4e5 picoseconds\u0026#34;], set_scale=100) #-\u0026gt;[399.99999999999994, \u0026lt; TmLiteral : nanosecond \u0026gt;] tauto2 = TmAutoScale(mode=\u0026#34;prefer_clock_units\u0026#34;) tauto2[\u0026#34;5e7 seconds\u0026#34;] #-\u0026gt; [1.5854895991882294, \u0026lt; TmLiteral : calender year \u0026gt;] tauto2[\u0026#34;5e4 seconds\u0026#34;] #-\u0026gt;[0.5787037037037037, \u0026lt; TmLiteral : day \u0026gt;] To print a value_pair properly the function TmFormat can be used:\ntime1 = parser[\u0026#34;5 ms\u0026#34;] time2 = parser[\u0026#34;1 ns\u0026#34;] print(TmFormat(time1, format=\u0026#34;full\u0026#34;)) #-\u0026gt; 5.0 milliseconds print(TmFormat(time1, format=\u0026#34;abbr\u0026#34;)) #-\u0026gt; 5.0 ms print(TmFormat(time2, format=\u0026#34;full\u0026#34;)) #-\u0026gt; 1.0 nanosecond print(TmFormat(time2, format=\u0026#34;abbr\u0026#34;)) #-\u0026gt; 1.0 ns Now my favorite feature: the Expression Parser can perform arithmetic operations on time values that have any arbitrary units. Operations that are currently supported : {+, - , *, /, %}.\nexp = TmExpParser() print(exp.parse(\u0026#34;10ms + 5ns + 10ms\u0026#34;)) #-\u0026gt; [0.020000005, \u0026lt; TmLiteral : second \u0026gt;] I did not have a use-case in mind for this feature. But I am sure that somebody else can. Just did this for fun.\nI hope you find this library useful! Below is a view of the library:\n","permalink":"https://yatharthb97.github.io/projects/python-time-literals/","summary":"Safe and accurate parsinggit status of time literals (values + units) is both common and crucial requirement. While C++ has a mechanism through STL chrono, such a functionality is absent in python (as per my information).\nLibrary: GitHub Gist.\nWhat is a time-literal? Just to be clear, time literal here means anything of this form : 5ns, 4min, 15.5ms. It is a numeric value (float) followed by alphabetic constants that indicate special treatment of the alpha-numeric string constant.","title":"Python Time Literals"},{"content":"Authored \u0026amp; Illustrated 1 The Romanticism of the Nib\n2 A forgotten book: The Dramatic History of India\nIllustrated \u0026amp; Edited 3 Satire Saturdays: The Leak\n4 Satire Saturdays - Crocodile: An Extraordinary Incident\n5 Satire Saturdays: Cat\u0026rsquo;s Cradle\n6 Satire Saturdays: A Case of Exploding Mangoes\n7 Satire Saturdays: The Master and Margarita\n","permalink":"https://yatharthb97.github.io/publications/beetlebox/","summary":"Authored \u0026amp; Illustrated 1 The Romanticism of the Nib\n2 A forgotten book: The Dramatic History of India\nIllustrated \u0026amp; Edited 3 Satire Saturdays: The Leak\n4 Satire Saturdays - Crocodile: An Extraordinary Incident\n5 Satire Saturdays: Cat\u0026rsquo;s Cradle\n6 Satire Saturdays: A Case of Exploding Mangoes\n7 Satire Saturdays: The Master and Margarita","title":"BeetleBox"},{"content":"1 - Powering a battery 2 - Coarse grain model of amyloid beta proteins ","permalink":"https://yatharthb97.github.io/publications/sciencethroughvisuals_tifrh/","summary":"1 - Powering a battery 2 - Coarse grain model of amyloid beta proteins ","title":"Science Through Visuals TIFRH"},{"content":" Ⓒ Yatharth Bhasin unless explicitly stated. Scroll down for credits. Hello! 120 lines for 1 radian patch\nDense patchy particle fluid\nExtended side patch\nHeterogenous mixture fluid\nInitialization with regular packing\nOnly side patch\n","permalink":"https://yatharthb97.github.io/gallery/patchyparticles/","summary":"Ⓒ Yatharth Bhasin unless explicitly stated. Scroll down for credits. Hello! 120 lines for 1 radian patch\nDense patchy particle fluid\nExtended side patch\nHeterogenous mixture fluid\nInitialization with regular packing\nOnly side patch","title":"Patchy Particles"},{"content":"KG Lab This page summarizes the projects I worked on during my Junior Research Fellow tenure at Tata Institute of Fundamental Research, Hyderabad.\nNote: Some of the links are private links and would require special access to view. Contact yatharth1997+git@gmail.com , if you have the permission to view the links but are unable to do so.\nDIY Correlator Card The source code for the Correlator card project can be found here: https://github.com/yatharthb97/Correlator .\nTeensy 4.1 Libraries: PITController : Embedded C++ : Describes a class to control the Periodic Interrupt Timer (PIT) of a PJRC Teensy 4.1 microcontroller. PIT_LifetimeTimer : Embedded C++ : Class Interface for using the Life Time Timer functionality of the Periodic Interrupt Timer (PIT) on Teensy 4.1 microcontroller. Quadtimer lib for Gate Counting. TODO Other Software Projects Brownian dynamics simulation of free dye in an FCS setup: [langsim] https://github.com/yatharthb97/langsim . Lattice simulation of FCS - simulation on microcontroller: [NOISE] https://github.com/yatharthb97/NOISE . Serial port interface objects for controlling multiple ports: [comms] https://github.com/yatharthb97/comms . Fluorometer Code Resources that were built for the in-house fluorometer.\nLinear Stage Fluorometer [Arduino]: https://github.com/yatharthb97/LinearStageFluorometer . Fluorometer Control Layer [PC side - python]: https://github.com/yatharthb97/FluorometerControlLayer . Syringe Dispenser Control Layer [Arduino and compiler on python]: https://github.com/yatharthb97/SyringeStage3D Fluorometer PCB files: TODO Generic old code / tests / single file sketches [Arduino and C++]: https://github.com/yatharthb97/Fluorometry . fcstools python module for filtering and analysis, and plotting of Fluorescence Correlation Spectroscopy (FCS) and Fluorescence Count Rate measurements.\nRepository link [python3]: https://github.com/yatharthb97/fcstools .\nAnalysis Scripts Analysis scripts for performed experiments is hosted at[ipython]: https://github.com/yatharthb97/KGLabAnalysis .\nMiscellaneous Code [not maintained] Repository link: https://github.com/yatharthb97/KGLabMiscCode .\n","permalink":"https://yatharthb97.github.io/projects/kglab/","summary":"KG Lab This page summarizes the projects I worked on during my Junior Research Fellow tenure at Tata Institute of Fundamental Research, Hyderabad.\nNote: Some of the links are private links and would require special access to view. Contact yatharth1997+git@gmail.com , if you have the permission to view the links but are unable to do so.\nDIY Correlator Card The source code for the Correlator card project can be found here: https://github.","title":"KG Lab Project Work"}]