<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Correlator Card Notes | Yatharth Bhasin</title>
<meta name=keywords content="projects"><meta name=description content="Project description."><meta name=author content="Yatharth Bhasin"><link rel=canonical href=https://yatharthb97.github.io/projects/correlator-card-notes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.296f1c593c14c1225e98bb70764ecc0ba42c9fb87f3b60196d6d71226602183b.css integrity="sha256-KW8cWTwUwSJemLtwdk7MC6Qsn7h/O2AZbW1xImYCGDs=" rel="preload stylesheet" as=style><link rel=icon href=https://yatharthb97.github.io/images/website_tile.svg><link rel=icon type=image/png sizes=16x16 href=https://yatharthb97.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yatharthb97.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yatharthb97.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yatharthb97.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yatharthb97.github.io/projects/correlator-card-notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.bootcdn.net/ajax/libs/mermaid/9.1.6/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0,theme:localStorage.getItem("pref-theme")==="dark"?"dark":"neutral"})</script><meta property="og:url" content="https://yatharthb97.github.io/projects/correlator-card-notes/"><meta property="og:site_name" content="Yatharth Bhasin"><meta property="og:title" content="Correlator Card Notes"><meta property="og:description" content="Project description."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2022-07-11T15:07:14+05:30"><meta property="article:modified_time" content="2022-07-11T15:07:14+05:30"><meta property="article:tag" content="Projects"><meta property="og:image" content="https://yatharthb97.github.io/%3Cimage%20path/url%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yatharthb97.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Correlator Card Notes"><meta name=twitter:description content="Project description."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"üî≠","item":"https://yatharthb97.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Correlator Card Notes","item":"https://yatharthb97.github.io/projects/correlator-card-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Correlator Card Notes","name":"Correlator Card Notes","description":"Project description.","keywords":["projects"],"articleBody":"Correlator Theory [version 1] by Yatharth Bhasin Introduction This article introduces and explains the implementation of Correlation modules that can read a time series and compute the autocorrelation function for the said time series.\nThe autocorrelation calculation is done for a set of lag time values, this set is also referred to as the Channels of the Correlator module. Hence $ACF(k) \\space or \\space G(k)$ refers to the $k^{th}$ channel.\nThe software module that manages the correlation is treated as a separate object entity. That means, each instance of the module completely describes the acquisition, calculation, and output of the data as required for a time series. All the different correlator modules, except the Logarithmic_Correlator derive from a base class called the Linear_Correlator_Base. This class defines a series of operations (functions) that are implemented by all different linear correlators types.\nThe subsequent sections will explain the simple model used - Simple Correlator System, then explain the different correlation module designs.\nIntroduction to Sources[^Incomplete] The primary sources used for this article and the code development are listed in this table:\nS. No. Author Title Year Publication Link 1 Yi Lug Real Time Multiple Tau Autocorrelator and its application in dynamic light scattering - Massey University 1996 Thesis - 2 Klaus Sch√§tzel , Martin Drewel \u0026 Sven Stimac Photon Correlation Measurements at Large Lag Times: Improving Statistical Accuracy 2007 Journal of Modern Optics https://www.tandfonline.com/doi/abs/10.1080/09500348814550731 3 Davide Magatti \u0026 Fabio Ferri Fast multi-tau real-time software correlator for dynamic light scattering 2001 Optical Society of America - Ubiquitous Language Defined This section defines terms that should be used consistently across documentation, code, and general discussions about the project.\nEntity Notation Description Gate time of counter module TTL-gt This is the time interval during which the counter module counts the TTL pulses and accumulates them. TTL-gt is also the minimum resolution of time available for autocorrelation calculation. Simple Correlator System The counter module is responsible for counting the pulses with a gate time $TTL-gt$.\nAs soon as the sample time $TTL-gt$ is over, the PI-t (Periodic Interrupt timer) signals a transfer of the collected photon counts to the Data Processing Unit (DPU). It should be noted here that during the transfer of data from the counter module to the DPU ‚Äî the counter is inactive until the transfer is done and the counter is reset for the next counting interval. This **dead time $t_{d}$ ** gives rise to an error. $$ Error = counting \\space dead \\space time / sampling \\space time * 100% $$ ==It might be possible to estimate this dead time by analyzing the clock cycles used by the transfer function.==\nIt is also essential that the time required for the computation of datum passed by the Counter to the DPU is less than the gate time $TTL-gt$. This is because the DPU needs to complete the (This point is also emphasized in Magatti \u0026 Ferri, 2001).\nHence, any implementation of a Correlator module that models the above schematics, must satisfy the following conditions:\nThe dead time during transfer $t_{d}$ must be small enough such that the loss is insignificant to the statistics ‚Äî as photon TTL pulses will be missed during that period. If the DPU processes data in real time, the time for computation $t_{c} \u003c TTL-gt$. And practically $t_{c} ¬´ TTL-gt$ Autocorrelation Theory Mean Photon Statistics We can formulate Intensity $I$ as the number of photons reaching the detector in unit time.\nThe mean number of detected pulses ($\\mu$) per sample time $\\Delta T = TTL-gt$ is given in terms of the Intensity $I$, quantum efficiency $p_{det}$ of the detector , which is (detected photons / arrived photons) $$ \\begin{align} \\langle n \\rangle = \\mu \u0026= p I \\Delta T\\ \\langle n_{j} \\rangle = \\mu_{j} \u0026= p \\int_{(j-1)\\Delta T}^{j\\Delta T}{I(t) \\space dt}\\ \\end{align} $$\nThe computation of this mean is trivial and is performed in the DPU in the so-called monitor channels. A monitor channel keeps track of the mean number of photons that arrive in a fixed gate time $TTL-gt$.\nAutocorrelation function The autocorrelation function can characterize the ‚Äúmemory‚Äù of a timeseries. The amplitude of the timeseries is usually randomly distributed, however, the recurrence of these fluctuations have a characteristic time scale that characterizes the memory of the system.\nMultiple definitions of the correlation functions are possible based on the factors like normalization scheme and noise corrections. We enlist the basic definitions used in our case. ==TODO: Include Pearson‚Äôs autocorrelation==\nWe first define the raw linear autocorrelation estimator: $$ G_{le}(k) = \\frac{1}{M}{\\sum_{i=1}^{M}{n_{i}n_{i-k}}} $$ Here, $M$ is the total sample size and $n_{i}$ represents photon counts which in turn represents Intensity. Hence $n_{i} \\approx I_{i}$. This estimator estimates the real autocorrelation function ($G_{n}(k)$) which assumes that $M ‚Üí \\infin$, hence, $\\langle G_{le}(k) \\rangle = G_{n}(k)$.\nThe use of the raw estimator with or without normalization is restricted to cases where the whole set $n_{i}$ is available such that $n_{i-k}$ is a defined entity. Hence, this scheme is not fit for real-time acquisition and calculation.\nRestructuring in terms of real time parameters We say that for time $m$, $0 \\leq m \u003c M$, the $m^{th}$ acquisition is made. Hence, at time $m$, $n_{m}$ is available and the available sample size of photon counts is also $m$.\nThe ACF Channels at any acquisition time $m$ represents the quantity : $$ Ch(k) = {\\sum_{i=0}^{m-k}{n_{i}n_{i-k}}} $$ To acquire the ACF from the correlator module, which is equivalent to acquiring the complete set of available Channels, ==a normalization must first be performed on the whole channel==.\nThis scheme yields the ==fundamental ACF== equation : $$ G(k) = \\frac{\\sum_{i=0}^{m-k}{n_{i}n_{i-k}}}{(Norm)} $$ Note the presence of the time dependent parameter $m$. It can be inferred from the above equation that for different values of the lag time $k$, the summation operations differ. For $k = 0$, $m$ sums are performed. And for $k = m - 1$, just one sum is performed. This is an artifact of the real time averaging, which is referred to as triangular averaging. Distortions that result from this triangular averaging can be estimated and can be managed. The schematic below illustrates the arrival of photon datum and its subsequent distribution to the different channels. This is due to the fact that complete $n_{i}$ series is not available for the ACF calculation and hence the relation $\\langle n_{i}n_{i-k} \\rangle = \\langle n_{i}n_{i+k} \\rangle$ cannot be used.\nFor all lags $k$, the contribution to the ACF is not equal. hence, the normalization depends on the lag value $k$. The normalization can also include the mean square photon count. Before completion of the acquisition phase, i.e. $m \u003c M$, the mean must also be estimated based on the available acquisitions. Note: $m$ represents the available samples. $$ Norm = (m-k) \\langle n \\rangle_{m}^{2} $$ ==All ACF values obtained in this way i.e. for $m \u003c M$ are estimates of the estimator $G_{le}(k)$ itself.==\nAfter completing the acquisition, i.e. for $m = M$, the above equations become: $$ \\begin{align} Ch(k) \u0026= {\\sum_{i=0}^{M-k}{n_{i}n_{i-k}}}\\ Norm \u0026= (M-k)\\langle n \\rangle^{2} \\end{align} $$ Note: for $m = M$, $\\langle n \\rangle_{m} ‚Üí \\langle n \\rangle$ . The estimated mean becomes the true sample mean.\nAnother form of ACF is possible, that characterizes the fluctuations from the mean value of the intensity. This is achieved by baseline subtraction of the estimated mean at time $m$, from the acquired intensity ‚Äî $\\langle n \\rangle_{m}^{2} $. $$ g(k) = \\frac{\\sum_{i=0}^{m-k}{(n_{i} - \\langle n \\rangle_{m})(n_{i-k} - \\langle n \\rangle_{m})}}{(Norm)} $$ This function is difficult to implement for real-time applications as for each acquisition, a set of subtractions involving the estimated mean $\\langle n \\rangle_{m}$ must be made. Also, since each channel contains contributions from many estimated-means, i.e. a set of $\\langle n \\rangle_{m}$ for many $m$. The error estimation is difficult.\nEstimation of mean $\\langle n \\rangle_{m}$ ‚Üí The previous section mentioned the use of ‚Äúmonitor-channels‚Äù for estimation of mean, this section will further illustrate that concept. If the calculation of the ACF is done in real time, it is obvious that the mean count rate $\\langle n \\rangle$ is also an estimated quantity. There are two approaches for the estimation of this quantity:\nUsing ‚Äúfar point channels‚Äù ‚Üí which uses far away ACF channels ‚Äî $\\langle n_{j} n_{j-k} \\rangle$ for very large $k$.\nFor large values of $k$, the values $n_{j}$ and $n_{j-k}$ are statistically independent (autocorrelation decays over large time interval). Hence,\n$$ \\langle n_{j} n_{j-k} \\rangle \\approx \\langle n_{j} \\rangle \\langle n_{j-k} \\rangle = \\langle n_{j} \\rangle^2 \\quad; k ¬ª 0 $$\nThe $\\langle n_{j} \\rangle^2$ is the asymptotic value of the autocorrelation function which is equivalent to $ACF(\\infin)$.\nUsing ‚Äúmonitor channels‚Äù ‚Üí which uses special counters that measure the average count rate of photon detection for a fixed sample duration $\\Delta T = TTL-gt$ ‚Äî $n$. $M$ is the number of samples received by the DPU from the counter. $$ n_{e} = \\frac{1}{m}\\sum_{j=1}^{m}{n_{j}} $$\n‚Üí My notes:\n‚Ä¢ It is unclear how the far-away channels can be used when the far-away channels are not even populated ‚Äî during the initial phase of the acquisition in real-time mode.\n‚Ä¢ Computation of mean using monitor channels can be implemented trivially as follows:\nMoved to : Repo/src/monitor_channel.hpp Linear Correlator - Software Interface Linear Correlator refers to an implementation of the correlation function that uses linear scale for lag values. It is the basic auto-correlation function discussed in the previous sections.\nWith collection of $M$ samples ‚Äî each sample collected over time interval $TTL-gt$, a linear estimator of the correlation function is possible (discussed in previous setions): $$ G_{le}(k) = \\frac{1}{M} \\sum_{j=1}^{M}{n_{j}n_{j-k}} $$\nNote from Multi-tau thesis (Yi Lui):[^TODO: Remove and add to a relavent section]\n‚ÄúHowever, at small lag times, $M$ has almost always to be a very large number ($10^6$ or more) in order to obtain sufficient averaging over photon counting noise.‚Äù\nsequenceDiagram Photon Data -\u003e\u003e Monitor Channel : Send Photon Data -\u003e\u003e Correlation Channel : Send \u0026 Compute Monitor Channel --\u003e\u003e Normalised ACF: Compute Correlation Channel --\u003e\u003e Normalised ACF : Compute Schematics for Base Lin_ACorr Interface (line_core_base.hpp) Schematics for a linear correlator.\n‚Üí The implementation of a linear correlator in code is implemented as class Lin_ACorr_Base. This object defines methods for any linear correlator that we want to design in code. The object class fulfills the following objectives:\nThe real-time implementations will contain an array Channel_array of size Channel_size that stores the computed ACF values at different lag times. This is the ‚ÄòChannels‚Äô or ‚ÄòACF Channels‚Äô.\nThe RT object will also contain an array Count_array of size Count_Array_size that stores the received samples.\nLinear_ACorr_Base::push_back() - function to receive data to the Sample_array - sample by sample. An internal call to Linear_ACorr_Base::push_to_channel() will process the received sample and compute its autocorrelation contribution - update the relevant ACF channels.\nFunction to receive multiple sample points and process ACF contributions for all the sample points in a single function.\nFunctions: For given state of Sample_array, compute the autocovariance and autocorrelation for a given lag value, compute the sample mean and sample variance, update the whole Channel_array for a given state of Sample_array.\nFor a time $m$, the maximum populated Sample_index is $m$ and also, the maximum populated Channel_index is also $m$. This tracking of the available indices must be done in order to compute the various quantities.\nAuxiliary functions to output the channels to different streams with appropriate normalization.\n‚Üí The Linear_ACorr_Base is inherited by the following objects to give different types of linear autocorrelators:\nLinCorr_RT - Real-time AC with no baseline subtraction and no normalization. ==‚Ä¢ Implementation Pending ‚Üì== LinCorr_RT_Baseline - Real-time LC with baseline subtraction but no normalization.` LinCorr_RT_BaselineNorm - Real time LC with baseline subtraction and also performs normalization using calculated mean.` LinCorr_RT_Norm - Real time LC with no baseline subtraction but performs normalization using calculated mean. Logarithmic Correlator Logarithmic correlator uses a lag times that are logarithmically scaled. This method allows calculation over large times with a relatively small number of Correlator channels.\nHowever, this scheme leads to correlation channels with very small sampling time and some channels with very large sample times (the extreme channels at both ends). This leads to distortion of the ACF which is an extreme triangular distortion.\nThis distortion can be kept under check by using lag times considerably larger than the total sample time: $k_{max} \\Delta T_{k} ¬´ \\sum{M \\Delta T} $.$\\ref{(Schatzel1988)}$[^Citation Pending]\nThe scaling of the lag time is given by:\n==The implementation of this schematics is pending.==\nMulti - Tau Correlator Multi-tau correlators utilize a group $S$ of linear correlators.\nHence, a multi-tau correlator object can be thought of as a block of $S$ linear correlators with a wrapper that contains functions that simultaneously update every one of the $S$ Linear Correlators in its scope. This wrapper can be implemented as a C++ style template.\ntemplate \u003cLin_CorrA_Base lin_corr_type, unsigned int S\u003e class Multi_Tau{}; ==The implementation of this correlator scheme is pending as work is still going for the Linear Correlators.==\nTimers \u0026 Counters This section provides a brief overview of teensy timers and their use for ACF calculations. The use cases described here are for the counting module. The DPU (Data Processing Unit) will be entirely handled by the software and a Serial Port.\nReference Tables Teensy 4.1 has several timer modules (timers relevant to this project are highlighted)[^For Reference] : (Source ‚Üí Manual)\n==General Purpose Timer (GPT): A 32-bit up-counter with 12-bit pre-scaler == ==‚Ä¢ Periodic Interrupt Timer (PIT): A 32-bit counter timer that features programmable count modulus, clock division features etc.== ==Quad Timer (TMR): It provides four timer channels with variety of controls for individual and multi-channel features== Quadrature Encoder/Decoder (ENC): It provides interfacing capability to position/ speed sensors ==Enhanced FlexPWM: It contains PWM submodules each of which is set up to control a single half bridge power stage== Watchdog Timer (WDOG1,2): The WDOG1 and WDOG2 protect against system failures by providing a method by which to escape from unexpected events or programming errors Watchdog timer (RTWDOG/WDOG3): It is a high reliability independent timer that is available for system use External Watchdog Monitor (EWM): It is designed to monitor external circuits, as well as the MCU software flow The pins that correspond to particular timers are as follows[^For Reference]: (Source ‚Üí PJRC Website)\nPWM Pins\nFlexPWM1 Module0 - Controls PWM pins 1, 44, 45. FlexPWM1 Module1 - Controls PWM pins 0, 42, 43. FlexPWM1 Module2 - Controls PWM pins 24, 46, 47. FlexPWM1 Module3 - Controls PWM pins 7, 8, 25. FlexPWM2 Module0 - Controls PWM pins 4, 33. FlexPWM2 Module1 - Controls PWM pin 5. FlexPWM2 Module2 - Controls PWM pins 6, 9. FlexPWM2 Module3 - Controls PWM pins 36, 37. FlexPWM3 Module0 - Controls PWM pin 53. FlexPWM3 Module1 - Controls PWM pins 28, 29. FlexPWM3 Module2 - No pins accessible. FlexPWM3 Module3 - Controls PWM pin 41. FlexPWM4 Module0 - Controls PWM pin 22. FlexPWM4 Module1 - Controls PWM pin 23. FlexPWM4 Module2 - Controls PWM pins 2, 3. FlexPWM4 Module3 - No pins accessible. QuadTimer1 Module0 - Controls PWM pin 10. QuadTimer1 Module1 - Controls PWM pin 12. QuadTimer1 Module2 - Controls PWM pin 11. QuadTimer1 Module3 - No pins accessible. QuadTimer2 Module0 - Controls PWM pin 13. QuadTimer2 Module1 - No pins accessible. QuadTimer2 Module2 - No pins accessible. QuadTimer2 Module3 - No pins accessible. QuadTimer3 Module0 - Controls PWM pin 19. QuadTimer3 Module1 - Controls PWM pin 18. QuadTimer3 Module2 - Controls PWM pin 14. QuadTimer3 Module3 - Controls PWM pin 15. QuadTimer4 Module0 - No pins accessible. Used by OctoWS2811 library, ADC Library QuadTimer4 Module1 - No pins accessible. Used by OctoWS2811 library QuadTimer4 Module2 - No pins accessible. Used by OctoWS2811 library QuadTimer4 Module3 - No pins accessible. Used by Audio for ADC timing, and ADC Library\nUbiquitous Language II Terminology Description Notation Counter-Gate Interval The (real) time duration during which TTL counting is done. It is the minimum time resolution available for ACF calculation. TTL-gt TTL Counter Counting / Timer peripheral responsible for counting the TTL pulses from the APD. TTL-t Periodic-interrupt Timer Signals the opening and closing of a new counter-interval. PI-t Interrupt Service Routine It is the function executed by an interrupt service. Special functions with prefix ISR_xxx() are used in some cases by the hardware. ISR Fast Interrupt Request An interrupt request made to the microcontroller of the ARM architecture that has the highest priority among the interrupts. It is executed the fastest. FIQ Reserved Timer List List of timers that are required for operation of Arduino library functions. The goal of the implementation should be to reduce the size of this list to zero by slowly eliminating the use of Arduino library functions. [^Other advantage of this would be speed gain.] ResTL Basics of Counters/Timers A timer is a counter with a clock input. A timer uses a regular and periodic pulsing source (a clock) to count up/down to a precise time duration. The precision of the timer, thus, depends completely on the precision of the input clock. Clock selection can be done using the CCM (Clock Controller Module).\nThe timer modules share some general characteristics and functions:1\nA timer can be turned on ‚Äî enabled by setting the Timer/Counter Control Register (TCCR) or simply Control Registers (CR). A timer can similarly be turned off by setting the appropriate bits in the TCCR, also if the timer supports multiple modes of operations, these are controlled by the TCCR as well. The count value of the counter is maintained in the Timer Count (TCNT) register. The initialization of TCNT, which is set after every complete cycle of the counter is done by the value stored in the Load Value (LDVAL) register. The Input Capture Register (ICR) holds the value of the counter from the last capture event. The Output Capture Register (OCR) holds the value that generates a ‚Äúcompare event‚Äù, usually an interrupt, when the counter reaches a certain set value. Prescalar Registers (PRs) sets the appropriate prescale value to the input clock of the counter. Usually prescalars of 8, 16, 256, etc are available with a counter module. If the counter/timer is used as a timer, and an input clock is provided. The selection of the input clock is done by the CLKSRC Clock Source Registers. If this feature is unavailable, the clock selection is handled by the CCM. The multiple IFQ interrupts for compare, capture, rollover, etc. can be enabled using the Interrupt Registers (IR). Flags for overflow, rollover, compare, and capture events are stored in the Status Registers(SR) . Other Flag registers hold the flags that are set by the different interrupt events. These flags can be read, or they internally control the triggering of ISRs. Manual clearing of flags has to be done in some cases for a reset of the timer module. Capture Event A capture event triggers a read of the current value in the count registers (TCNT) and a write to Input Capture Registers (ICR). The value can then be read from the ICR to the software memory. This function can be used to count arrival events during a fixed gated interval. This requires a trigger pulse to a particular capture pin of the timer.\n(Source: Manual)\nEach Input Capture Channel has a dedicated capture pin, capture register and input edge detection/selection logic. Each input capture function has an associated status flag, and can cause the processor to make an interrupt service request. (For GPT)\nReset Event A reset event is performed after one cycle of the timer/counter has elapsed. The resetting of the module for the next cycle involves setting of some control register bits and clearing of event flags. Some timers support auto-reset modes that will do the complete procedure.\nPeriodic Timing The first step is to fix the gating interval for the timer. Since, for an n-bit timer, the range is $2^{n} - 1$, exact timing operations can be set by setting a preload value in the LDVAL register. Hence the counting starts from a constant $a$ in the LDVAL.\nIf the input clock has a frequency $f$ , and a prescalar $p$, the timer‚Äôs counter increments by one for every: $$ \\begin{align} t_{inc} \u0026= \\frac{1}{f} * p = Period_{tick}\\ t_{instantaneous} \u0026= a + \\Big( \\frac{1}{f} * p \\Big) * ticks\\ \\end{align} $$ Say we need the timer to generate an event after each overflow, hence, a downcounting timer must be loaded with $LDVAL = cycles -1$, $$ cycles = TTL-gt / Period_{tick} $$\nBuilding a Counter Routine[^Obsolete] The schematic above outlines the basic proposed structure of the counting module. Whereas the calculation of the autocorrelation function is discussed in the above sections.\nThe counting module consists:\nA TTL counter (TTL-t) that receives the TTL pulses and counts them. This counter must be capable of storing counts that is comparable to the usual count rate in the experiment. Apart from that the counter must have a capture mechanism and a fast reset mechanism. The choice of this counter depends on the latency of these functions.\nThe range of an n-bit counter is given by: $2^{n} - 1 $. Hence a 16-bit counter has a range of 0-65,535 ($10^{4}$) and a 32-bit counter has a range of 0 - 4,294,967,295 ($~ 10^9$). Any 32-bit timer would have enough range to accommodate for any physically possible count rates. The range of a 16-bit timers (if forced to used - because of economy) can be doubled by checking the overflow flag. Timers set an overflow flag when they exceed their maximum value during counting, reset to zero and start counting again. Use of this method requires an additional operation of resetting the overflow flag during the next cycle of operation. This mechanism is already demonstrated in the lower half of the schematics.\nTaking into account the average count rates encountered during a typical single-molecule experiments (say $10^{4}-10^{6}$ cps for FCS), we can further evaluate the problem of overflows. The typical gating time is assumed to be 100 $\\mu s$. Hence, the maximum count value during a single gate interval is $\\approx 1-10^{2}$. It is clear that 16-bit timers are also well equipped in terms of the range. Hence, the selection would entirely depend on speed of operations and access and not on the size of the counters, however, 32-bit timers would be preffered.\nThe Service Time of an ISR is the time taken to complete the ISR prescribed for a timer. Since, in our case, the ISR will interact with the TTL-t, the performance will also depend heavily on the Service Time of the ISR.\nAn Periodic-interrupt timer (PI-t ) will be used to trigger the opening and closing of a Counter Interval (TTL-gt) on the TTl-t. The selection of the timer will depend on the Interrupt Latency of the timer.\nThe Interrupt Latency is the time between the raising of the interrupt by the timer module and the execution of the first instruction of the ISR. This delay is partly natural (context saving and switching, and a goto/jump instruction) and partly implementation dependent. The implementation dependent part is significant when multiple interrupts exist in the system within a priority hierarchy. It should also be noted that while one interrupt is running, all interrupts are disabled (The ISR is blocked within two function calls - sei() and cli()2). Hence, a running interrupt may readily block the timer interrupt from executing. ==(It is however unclear to me if the wiring is done in such a way that the interrupts are handled without the use of cpu, however, the value during the capture is copied in the main memory. - EDIT: DMA operations)== For this reason, to ensure reliability, only one interrupt must be used within the system, which will be used to control the TTL-C. The ISR_CI(), say, will take the following form:\nvoid ISR_CI() { //Capture Signal to TTL-C digitalWriteFast(TTLtCapturePin, HIGH); lowest_delay(); digitalWriteFast(TTLtCapturePin, LOW); //Or an equivalent \"Active Low Pulse\" //DMA trigger from Input Capture register of TTL-C to software memory //Reset-Event on the TTL-C } The precise timing of the periodic interrupt service is done using an onboard clock, usually a Real-time clock (RTC), Teensy 4.1 contains a 24MHz oscillator that can be used to keep track of ‚Äúreal time‚Äù. Otherwise, the Peripheral bus clock can be selected which operates at $f_{CPU}/4$.\nRationale : Using PIT for PI-t Its use with DMA channels is well defined and is a common use case.\n‚Ä¢ The DMAMUX has a special mode for using this timer.\n(Source: Manual, Page 77)\n‚Äú‚Üí Periodic Trigger mode :\nIn this mode, a DMA source may only request a DMA transfer, such as when a transmit buffer becomes empty or a receive buffer becomes full, periodically. Configuration of the period is done in the registers of the periodic interrupt timer (PIT). This mode is available only for channels 0 to 3.‚Äù\n‚Ä¢ Also, quoting from the description of the PIT timers (Features in page 2972):\n‚Ä¢ Read Page 78 onwards, section 5.4.1 for details.\nThe timer is optimized for delivering periodic pulses.\nThis timer module has four 32-bit channels and hence offers good resolution.\nThe bi-modality {Stop and Run} - which is also a lack of functionality, means that the timer can be reset very fast and is ideal for our use case.\nThe clock source can be selected as the 150 MHz Peripheral Clock, which gives a resolution (timeperiod) of about 6.67 nanoseconds.\nCons: Module does not have a prescalar. However, for our use case, we can do without a prescalar and 2 PIT channels can be chained together for a similar arrangement.\nThe abbreviations might change for the different timer modules, however, the concepts are the same. Also, the abbreviations will be easy to understand after grasping the ones mentioned above.¬†‚Ü©Ô∏é\nArduino.h defines: #define interrupts() sei() ; #define noInterrupts() cli()¬†‚Ü©Ô∏é\n","wordCount":"4295","inLanguage":"en","image":"https://yatharthb97.github.io/%3Cimage%20path/url%3E","datePublished":"2022-07-11T15:07:14+05:30","dateModified":"2022-07-11T15:07:14+05:30","author":{"@type":"Person","name":"Yatharth Bhasin"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yatharthb97.github.io/projects/correlator-card-notes/"},"publisher":{"@type":"Organization","name":"Yatharth Bhasin","logo":{"@type":"ImageObject","url":"https://yatharthb97.github.io/images/website_tile.svg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yatharthb97.github.io/ accesskey=h title="Yatharth Bhasin (Alt + H)"><img src=https://yatharthb97.github.io/images/header_button.gif alt aria-label=logo height=30>Yatharth Bhasin</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yatharthb97.github.io/aboutme/ title="about me"><span>about me</span></a></li><li><a href=https://yatharthb97.github.io/projects/ title=projects><span>projects</span></a></li><li><a href=https://yatharthb97.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://yatharthb97.github.io/publications/ title=publications><span>publications</span></a></li><li><a href=https://yatharthb97.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://yatharthb97.github.io/gallery/ title=gallery><span>gallery</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yatharthb97.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://yatharthb97.github.io/projects/>üî≠</a></div><h1 class=post-title>Correlator Card Notes</h1><div class=post-description>Project description.</div><div class=post-meta><span title='2022-07-11 15:07:14 +0530 +0530'>July 11, 2022</span>&nbsp;¬∑&nbsp;21 min&nbsp;¬∑&nbsp;4295 words&nbsp;¬∑&nbsp;Yatharth Bhasin&nbsp;|&nbsp;<a href=https://github.com/yatharthb97/yatharthb97.github.io/tree/main/content//projects/Correlator%20Card%20Notes.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#correlator-theory-version-1 aria-label="Correlator Theory [version 1]">Correlator Theory [version 1]</a><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#introduction-to-sourcesincomplete aria-label="Introduction to Sources[^Incomplete]">Introduction to Sources[^Incomplete]</a></li><li><a href=#ubiquitous-language-defined aria-label="Ubiquitous Language Defined">Ubiquitous Language Defined</a></li><li><a href=#simple-correlator-system aria-label="Simple Correlator System">Simple Correlator System</a></li><li><a href=#autocorrelation-theory aria-label="Autocorrelation Theory">Autocorrelation Theory</a><ul><li><a href=#mean-photon-statistics aria-label="Mean Photon Statistics">Mean Photon Statistics</a></li><li><a href=#autocorrelation-function aria-label="Autocorrelation function">Autocorrelation function</a><ul><li><a href=#restructuring-in-terms-of-real-time-parameters aria-label="Restructuring in terms of real time parameters">Restructuring in terms of real time parameters</a></li></ul></li></ul></li><li><a href=#estimation-of-mean-langle-n-rangle_m aria-label="Estimation of mean $\langle n \rangle_{m}$">Estimation of mean $\langle n \rangle_{m}$</a></li><li><a href=#linear-correlator---software-interface aria-label="Linear Correlator - Software Interface">Linear Correlator - Software Interface</a><ul><ul><li><a href=#schematics-for-base-lin_acorr-interface-line_core_basehpp aria-label="Schematics for Base Lin_ACorr Interface (line_core_base.hpp)">Schematics for Base Lin_ACorr Interface (line_core_base.hpp)</a></li></ul></ul></li><li><a href=#logarithmic-correlator aria-label="Logarithmic Correlator">Logarithmic Correlator</a></li><li><a href=#multi---tau-correlator aria-label="Multi - Tau Correlator">Multi - Tau Correlator</a></li><li><a href=#timers--counters aria-label="Timers & Counters">Timers & Counters</a><ul><li><a href=#reference-tables aria-label="Reference Tables">Reference Tables</a></li><li><a href=#ubiquitous-language-ii aria-label="Ubiquitous Language II">Ubiquitous Language II</a></li><li><a href=#basics-of-counterstimers aria-label="Basics of Counters/Timers">Basics of Counters/Timers</a><ul><li><a href=#capture-event aria-label="Capture Event">Capture Event</a></li><li><a href=#reset-event aria-label="Reset Event">Reset Event</a></li><li><a href=#periodic-timing aria-label="Periodic Timing">Periodic Timing</a></li></ul></li><li><a href=#building-a-counter-routineobsolete aria-label="Building a Counter Routine[^Obsolete]">Building a Counter Routine[^Obsolete]</a></li></ul></li><li><a href=#rationale--using-pit-for-pi-t aria-label="Rationale : Using PIT for PI-t">Rationale : Using PIT for PI-t</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=correlator-theory-version-1>Correlator Theory [version 1]<a hidden class=anchor aria-hidden=true href=#correlator-theory-version-1>#</a></h1><div style=text-align:center>by Yatharth Bhasin</div><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>This article introduces and explains the implementation of Correlation modules that can read a time series and compute the <em>autocorrelation function</em> for the said time series.</p><p>The autocorrelation calculation is done for a set of <em>lag time values</em>, this set is also referred to as the <em>Channels</em> of the Correlator module. Hence $ACF(k) \space or \space G(k)$ refers to the $k^{th}$ channel.</p><p>The software module that manages the correlation is treated as a separate object entity. That means, each instance of the module completely describes the <em>acquisition, calculation, and output</em> of the data as required for a time series. All the different correlator modules, except the <code>Logarithmic_Correlator</code> derive from a base class called the <code>Linear_Correlator_Base</code>. This class defines a series of operations (functions) that are implemented by all different linear correlators types.</p><p>The subsequent sections will explain the simple model used - <em>Simple Correlator System</em>, then explain the different correlation module designs.</p><h2 id=introduction-to-sourcesincomplete>Introduction to Sources[^Incomplete]<a hidden class=anchor aria-hidden=true href=#introduction-to-sourcesincomplete>#</a></h2><p>The primary sources used for this article and the code development are listed in this table:</p><table><thead><tr><th style=text-align:center>S. No.</th><th style=text-align:center>Author</th><th style=text-align:center>Title</th><th style=text-align:center>Year</th><th style=text-align:left>Publication</th><th style=text-align:left>Link</th></tr></thead><tbody><tr><td style=text-align:center>1</td><td style=text-align:center>Yi Lug</td><td style=text-align:center>Real Time Multiple Tau Autocorrelator and its application in dynamic light scattering - Massey University</td><td style=text-align:center>1996</td><td style=text-align:left>Thesis</td><td style=text-align:left>-</td></tr><tr><td style=text-align:center>2</td><td style=text-align:center>Klaus Sch√§tzel , Martin Drewel & Sven Stimac</td><td style=text-align:center>Photon Correlation Measurements at Large Lag Times: Improving Statistical Accuracy</td><td style=text-align:center>2007</td><td style=text-align:left>Journal of Modern Optics</td><td style=text-align:left><a href=https://www.tandfonline.com/doi/abs/10.1080/09500348814550731>https://www.tandfonline.com/doi/abs/10.1080/09500348814550731</a></td></tr><tr><td style=text-align:center>3</td><td style=text-align:center>Davide Magatti & Fabio Ferri</td><td style=text-align:center>Fast multi-tau real-time software correlator for dynamic light scattering</td><td style=text-align:center>2001</td><td style=text-align:left>Optical Society of America</td><td style=text-align:left>-</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:left></td><td style=text-align:left></td></tr></tbody></table><h2 id=ubiquitous-language-defined>Ubiquitous Language Defined<a hidden class=anchor aria-hidden=true href=#ubiquitous-language-defined>#</a></h2><p>This section defines terms that should be used consistently across documentation, code, and general discussions about the project.</p><table><thead><tr><th>Entity</th><th>Notation</th><th>Description</th></tr></thead><tbody><tr><td>Gate time of counter module</td><td>TTL-gt</td><td>This is the time interval during which the counter module counts the TTL pulses and accumulates them. TTL-gt is also the minimum resolution of time available for autocorrelation calculation.</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id=simple-correlator-system>Simple Correlator System<a hidden class=anchor aria-hidden=true href=#simple-correlator-system>#</a></h2><p><link rel=stylesheet href=/css/hugo-easy-gallery.css><div class=box><figure itemprop=associatedMedia itemscope itemtype=http://schema.org/ImageObject><div class=img><img itemprop=thumbnail src=/images/articles/projects/correlator/image-20210807120802430.png></div><a href=/images/articles/projects/correlator/image-20210807120802430.png itemprop=contentUrl></a></figure></div><script src=https://code.jquery.com/jquery-1.12.4.min.js integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin=anonymous></script><script src=/js/load-photoswipe.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin=anonymous></script><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></p><p>The counter module is responsible for counting the pulses with a <em>gate time $TTL-gt$</em>.</p><p>As soon as the sample time $TTL-gt$ is over, the <em>PI-t (Periodic Interrupt timer)</em> signals a transfer of the collected photon counts to the <em>Data Processing Unit (DPU)</em>. It should be noted here that during the transfer of data from the counter module to the DPU ‚Äî the counter is inactive until the transfer is done and the counter is reset for the next counting interval. This **dead time $t_{d}$ ** gives rise to an error.
$$
Error = counting \space dead \space time / sampling \space time * 100%
$$
==It might be possible to estimate this dead time by analyzing the clock cycles used by the transfer function.==</p><p>It is also essential that the time required for the computation of datum passed by the Counter to the DPU is less than the gate time $TTL-gt$. This is because the DPU needs to complete the (This point is also emphasized in Magatti & Ferri, 2001).</p><p><strong>Hence, any implementation of a Correlator module that models the above schematics, must satisfy the following conditions:</strong></p><ol><li>The dead time during transfer $t_{d}$ must be small enough such that the loss is insignificant to the statistics ‚Äî as photon TTL pulses will be missed during that period.</li><li>If the DPU processes data in real time, the time for computation $t_{c} &lt; TTL-gt$. And practically $t_{c} &#171; TTL-gt$</li></ol><h2 id=autocorrelation-theory>Autocorrelation Theory<a hidden class=anchor aria-hidden=true href=#autocorrelation-theory>#</a></h2><h3 id=mean-photon-statistics>Mean Photon Statistics<a hidden class=anchor aria-hidden=true href=#mean-photon-statistics>#</a></h3><p>We can formulate <em>Intensity $I$</em> as the number of photons reaching the detector in unit time.</p><p>The mean number of detected pulses ($\mu$) per sample time $\Delta T = TTL-gt$ is given in terms of the <em>Intensity $I$</em>, <em>quantum efficiency $p_{det}$ of the detector</em> , which is <em>(detected photons / arrived photons)</em>
$$
\begin{align}
\langle n \rangle = \mu &= p I \Delta T\
\langle n_{j} \rangle = \mu_{j} &= p \int_{(j-1)\Delta T}^{j\Delta T}{I(t) \space dt}\
\end{align}
$$</p><p>The computation of this mean is trivial and is performed in the DPU in the so-called <em>monitor channels.</em> <strong>A monitor channel keeps track of the mean number of photons that arrive in a fixed gate time $TTL-gt$.</strong></p><h3 id=autocorrelation-function>Autocorrelation function<a hidden class=anchor aria-hidden=true href=#autocorrelation-function>#</a></h3><p>The autocorrelation function can characterize the &ldquo;memory&rdquo; of a timeseries. The amplitude of the timeseries is usually randomly distributed, however, the recurrence of these fluctuations have a characteristic time scale that characterizes the memory of the system.</p><p>Multiple definitions of the correlation functions are possible based on the factors like normalization scheme and noise corrections. We enlist the basic definitions used in our case. ==TODO: Include Pearson&rsquo;s autocorrelation==</p><p>We first define the raw linear autocorrelation estimator:
$$
G_{le}(k) = \frac{1}{M}{\sum_{i=1}^{M}{n_{i}n_{i-k}}}
$$
Here, $M$ is the total sample size and $n_{i}$ represents photon counts which in turn represents Intensity. Hence $n_{i} \approx I_{i}$. This estimator estimates the real autocorrelation function ($G_{n}(k)$) which assumes that $M ‚Üí \infin$, hence, $\langle G_{le}(k) \rangle = G_{n}(k)$.</p><p>The use of the raw estimator with or without normalization is restricted to cases where the whole set $n_{i}$ is available such that $n_{i-k}$ is a defined entity. Hence, this scheme is not fit for <em>real-time acquisition and calculation.</em></p><h4 id=restructuring-in-terms-of-real-time-parameters>Restructuring in terms of real time parameters<a hidden class=anchor aria-hidden=true href=#restructuring-in-terms-of-real-time-parameters>#</a></h4><p>We say that for time $m$, $0 \leq m &lt; M$, the $m^{th}$ acquisition is made. Hence, at time $m$, $n_{m}$ is available and the <em><u>available sample size of photon counts</u></em> is also $m$.</p><p>The ACF Channels at any acquisition time $m$ represents the quantity :
$$
Ch(k) = {\sum_{i=0}^{m-k}{n_{i}n_{i-k}}}
$$
To acquire the ACF from the correlator module, which is equivalent to acquiring the complete set of available Channels, ==a normalization must first be performed on the whole channel==.</p><p>This scheme yields the ==<em>fundamental ACF</em>== equation :
$$
G(k) = \frac{\sum_{i=0}^{m-k}{n_{i}n_{i-k}}}{(Norm)}
$$
Note the presence of the time dependent parameter $m$. It can be inferred from the above equation that for different values of the lag time $k$, the summation operations differ. For $k = 0$, $m$ sums are performed. And for $k = m - 1$, just one sum is performed. This is an artifact of the real time averaging, which is referred to as <strong>triangular averaging.</strong> Distortions that result from this triangular averaging can be estimated and can be managed. The schematic below illustrates the arrival of photon datum and its subsequent distribution to the different channels. This is due to the fact that complete $n_{i}$ series is not available for the ACF calculation and hence the relation $\langle n_{i}n_{i-k} \rangle = \langle n_{i}n_{i+k} \rangle$ cannot be used.</p><p><img alt=image-20210807124050295 loading=lazy src=c:/Users/Yatharth_Nitro/AppData/Roaming/Typora/typora-user-images/image-20210807124050295.png></p><p>For all lags $k$, the contribution to the ACF is not equal. hence, the normalization depends on the lag value $k$. The normalization can also include the mean square photon count. Before completion of the acquisition phase, i.e. $m &lt; M$, the mean must also be estimated based on the available acquisitions. <u>Note: $m$ represents the available samples.</u>
$$
Norm = (m-k) \langle n \rangle_{m}^{2}
$$
==All ACF values obtained in this way i.e. for $m &lt; M$ are <em><u>estimates of the estimator</u> $G_{le}(k)$</em> itself.==</p><p>After completing the acquisition, i.e. for $m = M$, the above equations become:
$$
\begin{align}
Ch(k) &= {\sum_{i=0}^{M-k}{n_{i}n_{i-k}}}\
Norm &= (M-k)\langle n \rangle^{2}
\end{align}
$$
Note: for $m = M$, $\langle n \rangle_{m} ‚Üí \langle n \rangle$ . The estimated mean becomes the true sample mean.</p><p>Another form of ACF is possible, that characterizes the <u>fluctuations from the mean value of the intensity.</u> This is achieved by baseline subtraction of the estimated mean at time $m$, from the acquired intensity ‚Äî $\langle n \rangle_{m}^{2} $.
$$
g(k) = \frac{\sum_{i=0}^{m-k}{(n_{i} - \langle n \rangle_{m})(n_{i-k} - \langle n \rangle_{m})}}{(Norm)}
$$
This function is difficult to implement for real-time applications as for each acquisition, a set of subtractions involving the estimated mean $\langle n \rangle_{m}$ must be made. Also, since each channel contains contributions from many estimated-means, i.e. a set of $\langle n \rangle_{m}$ for many $m$. The error estimation is difficult.</p><h2 id=estimation-of-mean-langle-n-rangle_m>Estimation of mean $\langle n \rangle_{m}$<a hidden class=anchor aria-hidden=true href=#estimation-of-mean-langle-n-rangle_m>#</a></h2><p>‚Üí The previous section mentioned the use of &ldquo;monitor-channels&rdquo; for estimation of mean, this section will further illustrate that concept. If the calculation of the ACF is done in real time, it is obvious that the mean count rate $\langle n \rangle$ is also an estimated quantity. There are two approaches for the estimation of this quantity:</p><ol><li><p>Using <em><strong>&ldquo;far point channels&rdquo;</strong></em> ‚Üí which uses far away ACF channels ‚Äî $\langle n_{j} n_{j-k} \rangle$ for very large $k$.</p><p>For large values of $k$, the values $n_{j}$ and $n_{j-k}$ are statistically independent <u>(autocorrelation decays over large time interval)</u>. Hence,</p></li></ol><p>$$
\langle n_{j} n_{j-k} \rangle \approx \langle n_{j} \rangle \langle n_{j-k} \rangle = \langle n_{j} \rangle^2 \quad; k &#187; 0
$$</p><p>The $\langle n_{j} \rangle^2$ is the asymptotic value of the autocorrelation function which is equivalent to $ACF(\infin)$.</p><ol start=2><li>Using &ldquo;<em><strong>monitor channels</strong></em>&rdquo; ‚Üí which uses special counters that measure the average count rate of photon detection for a fixed sample duration $\Delta T = TTL-gt$ ‚Äî $n$. $M$ is the number of samples received by the DPU from the counter.</li></ol><p>$$
n_{e} = \frac{1}{m}\sum_{j=1}^{m}{n_{j}}
$$</p><blockquote><p>‚Üí My notes:</p><p>‚Ä¢ It is unclear how the far-away channels can be used when the far-away channels are not even populated ‚Äî during the initial phase of the acquisition in real-time mode.</p><p>‚Ä¢ Computation of mean using monitor channels can be implemented trivially as follows:</p></blockquote><blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Moved</span> <span class=nl>to</span> <span class=p>:</span> <span class=n>Repo</span><span class=o>/</span><span class=n>src</span><span class=o>/</span><span class=n>monitor_channel</span><span class=p>.</span><span class=n>hpp</span>
</span></span></code></pre></div></blockquote><h2 id=linear-correlator---software-interface>Linear Correlator - Software Interface<a hidden class=anchor aria-hidden=true href=#linear-correlator---software-interface>#</a></h2><p><em>Linear Correlator</em> refers to an implementation of the correlation function that uses linear scale for lag values. It is the basic auto-correlation function discussed in the previous sections.</p><p>With collection of $M$ samples ‚Äî each sample collected over time interval $TTL-gt$, a linear estimator of the correlation function is possible (discussed in previous setions):
$$
G_{le}(k) = \frac{1}{M} \sum_{j=1}^{M}{n_{j}n_{j-k}}
$$</p><blockquote><p>Note from Multi-tau thesis (Yi Lui):[^TODO: Remove and add to a relavent section]</p><p>&ldquo;However, at small lag times, $M$ has almost always to be a very large number ($10^6$ or more) in order to obtain sufficient averaging over photon counting noise.&rdquo;</p></blockquote><div class=mermaid>sequenceDiagram
Photon Data ->> Monitor Channel : Send
Photon Data ->> Correlation Channel : Send & Compute
    Monitor Channel -->> Normalised ACF: Compute
Correlation Channel -->> Normalised ACF : Compute</div><h4 id=schematics-for-base-lin_acorr-interface-line_core_basehpp>Schematics for Base Lin_ACorr Interface (<code>line_core_base.hpp</code>)<a hidden class=anchor aria-hidden=true href=#schematics-for-base-lin_acorr-interface-line_core_basehpp>#</a></h4><p><img alt=image-20210807141430194 loading=lazy src=/images/articles/projects/correlator/image-20210807141430194.png></p><p><em>Schematics for a linear correlator.</em></p><p>‚Üí The implementation of a linear correlator in code is implemented as <code>class Lin_ACorr_Base</code>. This object defines methods for any linear correlator that we want to design in code. The object class fulfills the following objectives:</p><ul><li><p>The real-time implementations will contain an array <code>Channel_array</code> of size <code>Channel_size</code> that stores the computed ACF values at different lag times. This is the &lsquo;Channels&rsquo; or &lsquo;ACF Channels&rsquo;.</p></li><li><p>The RT object will also contain an array <code>Count_array</code> of size <code>Count_Array_size</code> that stores the received samples.</p></li><li><p><code>Linear_ACorr_Base::push_back()</code> - function to receive data to the <code>Sample_array</code> - sample by sample. An internal call to <code>Linear_ACorr_Base::push_to_channel()</code> will process the received sample and compute its autocorrelation contribution - update the relevant ACF channels.</p></li><li><p>Function to receive multiple sample points and process ACF contributions for all the sample points in a single function.</p></li><li><p>Functions: For given state of <code>Sample_array</code>, compute the autocovariance and autocorrelation for a given lag value, compute the sample mean and sample variance, update the whole <code>Channel_array</code> for a given state of <code>Sample_array</code>.</p></li><li><p>For a time $m$, the maximum populated <code>Sample_index</code> is $m$ and also, the maximum populated <code>Channel_index</code> is also $m$. This tracking of the available indices must be done in order to compute the various quantities.</p></li><li><p>Auxiliary functions to output the channels to different streams with appropriate normalization.</p></li></ul><p>‚Üí The <code>Linear_ACorr_Base</code> is inherited by the following objects to give different types of linear autocorrelators:</p><ul><li><code>LinCorr_RT</code> - Real-time AC with no baseline subtraction and no normalization.</li><li>==‚Ä¢ Implementation Pending ‚Üì==</li><li><code>LinCorr_RT_Baseline</code> - Real-time LC with baseline subtraction but no normalization.`</li><li><code>LinCorr_RT_BaselineNorm</code> - Real time LC with baseline subtraction and also performs normalization using calculated mean.`</li><li><code>LinCorr_RT_Norm</code> - Real time LC with no baseline subtraction but performs normalization using calculated mean.</li></ul><h2 id=logarithmic-correlator>Logarithmic Correlator<a hidden class=anchor aria-hidden=true href=#logarithmic-correlator>#</a></h2><p>Logarithmic correlator uses a lag times that are logarithmically scaled. This method allows calculation over large times with a relatively small number of Correlator channels.</p><p>However, this scheme leads to correlation channels with very small sampling time and some channels with very large sample times (the extreme channels at both ends). This leads to distortion of the ACF which is an extreme triangular distortion.</p><p>This distortion can be kept under check by using lag times considerably larger than the total sample time: $k_{max} \Delta T_{k} &#171; \sum{M \Delta T} $.$\ref{(Schatzel1988)}$[^Citation Pending]</p><p>The scaling of the lag time is given by:</p><p><img alt=image-20210713125340590 loading=lazy src=c:/Users/Yatharth_Nitro/AppData/Roaming/Typora/typora-user-images/image-20210713125340590.png title="Source: Yi Lug 1996"></p><p>==The implementation of this schematics is pending.==</p><h2 id=multi---tau-correlator>Multi - Tau Correlator<a hidden class=anchor aria-hidden=true href=#multi---tau-correlator>#</a></h2><p>Multi-tau correlators utilize a group $S$ of linear correlators.</p><p><img alt=image-20210713125711991 loading=lazy src=/images/articles/projects/correlator/image-20210713125711991.png title="Source: Magatti & Ferri 2001"></p><p>Hence, a multi-tau correlator object can be thought of as a block of $S$ linear correlators with a wrapper that contains functions that simultaneously update every one of the $S$ Linear Correlators in its scope. This wrapper can be implemented as a C++ style template.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=n>Lin_CorrA_Base</span> <span class=n>lin_corr_type</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>S</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Multi_Tau</span><span class=p>{};</span>
</span></span></code></pre></div><p>==The implementation of this correlator scheme is pending as work is still going for the Linear Correlators.==</p><h2 id=timers--counters>Timers & Counters<a hidden class=anchor aria-hidden=true href=#timers--counters>#</a></h2><p>This section provides a brief overview of teensy timers and their use for ACF calculations. The use cases described here are for the counting module. The DPU (Data Processing Unit) will be entirely handled by the software and a Serial Port.</p><h3 id=reference-tables>Reference Tables<a hidden class=anchor aria-hidden=true href=#reference-tables>#</a></h3><ol><li>Teensy 4.1 has several timer modules (timers relevant to this project are highlighted)[^For Reference] :</li></ol><blockquote><p>(Source ‚Üí Manual)</p><ul><li>==General Purpose Timer (GPT): A 32-bit up-counter with 12-bit pre-scaler ==</li><li>==‚Ä¢ Periodic Interrupt Timer (PIT): A 32-bit counter timer that features programmable count modulus, clock division features etc.==</li><li>==Quad Timer (TMR): It provides four timer channels with variety of controls for individual and multi-channel features==</li><li>Quadrature Encoder/Decoder (ENC): It provides interfacing capability to position/ speed sensors</li><li>==Enhanced FlexPWM: It contains PWM submodules each of which is set up to control a single half bridge power stage==</li><li>Watchdog Timer (WDOG1,2): The WDOG1 and WDOG2 protect against system failures by providing a method by which to escape from unexpected events or programming errors</li><li>Watchdog timer (RTWDOG/WDOG3): It is a high reliability independent timer that is available for system use</li><li>External Watchdog Monitor (EWM): It is designed to monitor external circuits, as well as the MCU software flow</li></ul></blockquote><ol start=2><li>The pins that correspond to particular timers are as follows[^For Reference]:</li></ol><ul><li><blockquote><p>(Source ‚Üí PJRC Website)</p><p><u>PWM Pins</u></p><p>FlexPWM1 Module0 - Controls PWM pins 1, 44, 45.
FlexPWM1 Module1 - Controls PWM pins 0, 42, 43.
FlexPWM1 Module2 - Controls PWM pins 24, 46, 47.
FlexPWM1 Module3 - Controls PWM pins 7, 8, 25.
FlexPWM2 Module0 - Controls PWM pins 4, 33.
FlexPWM2 Module1 - Controls PWM pin 5.
FlexPWM2 Module2 - Controls PWM pins 6, 9.
FlexPWM2 Module3 - Controls PWM pins 36, 37.
FlexPWM3 Module0 - Controls PWM pin 53.
FlexPWM3 Module1 - Controls PWM pins 28, 29.
FlexPWM3 Module2 - No pins accessible.
FlexPWM3 Module3 - Controls PWM pin 41.
FlexPWM4 Module0 - Controls PWM pin 22.
FlexPWM4 Module1 - Controls PWM pin 23.
FlexPWM4 Module2 - Controls PWM pins 2, 3.
FlexPWM4 Module3 - No pins accessible.
QuadTimer1 Module0 - Controls PWM pin 10.
QuadTimer1 Module1 - Controls PWM pin 12.
QuadTimer1 Module2 - Controls PWM pin 11.
QuadTimer1 Module3 - No pins accessible.
QuadTimer2 Module0 - Controls PWM pin 13.
QuadTimer2 Module1 - No pins accessible.
QuadTimer2 Module2 - No pins accessible.
QuadTimer2 Module3 - No pins accessible.
QuadTimer3 Module0 - Controls PWM pin 19.
QuadTimer3 Module1 - Controls PWM pin 18.
QuadTimer3 Module2 - Controls PWM pin 14.
QuadTimer3 Module3 - Controls PWM pin 15.
QuadTimer4 Module0 - No pins accessible. Used by OctoWS2811 library, ADC Library
QuadTimer4 Module1 - No pins accessible. Used by OctoWS2811 library
QuadTimer4 Module2 - No pins accessible. Used by OctoWS2811 library
QuadTimer4 Module3 - No pins accessible. Used by Audio for ADC timing, and ADC Library</p></blockquote><h3 id=ubiquitous-language-ii>Ubiquitous Language II<a hidden class=anchor aria-hidden=true href=#ubiquitous-language-ii>#</a></h3><table><thead><tr><th style=text-align:right>Terminology</th><th>Description</th><th>Notation</th></tr></thead><tbody><tr><td style=text-align:right>Counter-Gate Interval</td><td>The (real) time duration during which TTL counting is done. It is the minimum time resolution available for ACF calculation.</td><td>TTL-gt</td></tr><tr><td style=text-align:right>TTL Counter</td><td>Counting / Timer peripheral responsible for counting the TTL pulses from the APD.</td><td>TTL-t</td></tr><tr><td style=text-align:right>Periodic-interrupt Timer</td><td>Signals the opening and closing of a new counter-interval.</td><td>PI-t</td></tr><tr><td style=text-align:right>Interrupt Service Routine</td><td>It is the function executed by an interrupt service. Special functions with prefix ISR_xxx() are used in some cases by the hardware.</td><td>ISR</td></tr><tr><td style=text-align:right>Fast Interrupt Request</td><td>An interrupt request made to the microcontroller of the ARM architecture that has the highest priority among the interrupts. It is executed the fastest.</td><td>FIQ</td></tr><tr><td style=text-align:right>Reserved Timer List</td><td>List of timers that are required for operation of Arduino library functions. The goal of the implementation should be to reduce the size of this list to zero by slowly eliminating the use of Arduino library functions. [^Other advantage of this would be speed gain.]</td><td>ResTL</td></tr><tr><td style=text-align:right></td><td></td><td></td></tr><tr><td style=text-align:right></td><td></td><td></td></tr><tr><td style=text-align:right></td><td></td><td></td></tr></tbody></table><h3 id=basics-of-counterstimers>Basics of Counters/Timers<a hidden class=anchor aria-hidden=true href=#basics-of-counterstimers>#</a></h3><p><strong>A timer is a counter with a clock input.</strong> A timer uses a regular and periodic pulsing source (a clock) to count up/down to a precise time duration. The precision of the timer, thus, depends completely on the precision of the input clock. Clock selection can be done using the <em>CCM (Clock Controller Module)</em>.</p><p>The timer modules share some general characteristics and functions:<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><ol><li>A timer can be turned on ‚Äî enabled by setting the <u>T</u>imer/<u>C</u>ounter <u>C</u>ontrol <u>R</u>egister (TCCR) or simply Control Registers (CR).</li><li>A timer can similarly be turned off by setting the appropriate bits in the TCCR, also if the timer supports multiple modes of operations, these are controlled by the TCCR as well.</li><li>The count value of the counter is maintained in the <u>T</u>imer <u>C</u>ou<u>nt</u> (TCNT) register.</li><li>The initialization of TCNT, which is set after every complete cycle of the counter is done by the value stored in the <u>L</u>oa<u>d</u> <u>Val</u>ue (LDVAL) register.</li><li>The <u>I</u>nput <u>C</u>apture <u>R</u>egister (ICR) holds the value of the counter from the last capture event.</li><li>The <u>O</u>utput <u>C</u>apture <u>R</u>egister (OCR) holds the value that generates a &ldquo;compare event&rdquo;, usually an interrupt, when the counter reaches a certain set value.</li><li><u>P</u>rescalar <u>R</u>egisters (PRs) sets the appropriate prescale value to the input clock of the counter. Usually prescalars of 8, 16, 256, etc are available with a counter module.</li><li>If the counter/timer is used as a timer, and an input clock is provided. The selection of the input clock is done by the <em>CLKSRC <u>Cl</u>oc<u>k</u> <u>S</u>ou<u>rc</u>e Registers.</em> If this feature is unavailable, the clock selection is handled by the CCM.</li><li>The multiple IFQ interrupts for compare, capture, rollover, etc. can be enabled using the <em>Interrupt Registers (IR)</em>.</li><li>Flags for overflow, rollover, compare, and capture events are stored in the <em>Status Registers(SR) .</em></li><li>Other Flag registers hold the flags that are set by the different interrupt events. These flags can be read, or they internally control the triggering of ISRs. Manual clearing of flags has to be done in some cases for a reset of the timer module.</li></ol><h4 id=capture-event>Capture Event<a hidden class=anchor aria-hidden=true href=#capture-event>#</a></h4><p>A capture event triggers a read of the current value in the count registers (TCNT) and a write to Input Capture Registers (ICR). The value can then be read from the ICR to the software memory. This function can be used to count arrival events during a fixed gated interval. This requires a trigger pulse to a particular capture pin of the timer.</p><blockquote><p>(Source: Manual)</p><p>Each Input Capture Channel has a dedicated capture pin, capture register and input edge detection/selection logic. Each input capture function has an associated status flag, and can cause the processor to make an interrupt service request. (For GPT)</p></blockquote><h4 id=reset-event>Reset Event<a hidden class=anchor aria-hidden=true href=#reset-event>#</a></h4><p>A reset event is performed after one cycle of the timer/counter has elapsed. The resetting of the module for the next cycle involves setting of some control register bits and clearing of event flags. Some timers support auto-reset modes that will do the complete procedure.</p><h4 id=periodic-timing>Periodic Timing<a hidden class=anchor aria-hidden=true href=#periodic-timing>#</a></h4><p>The first step is to fix the gating interval for the timer. Since, for an n-bit timer, the range is $2^{n} - 1$, exact timing operations can be set by setting a preload value in the LDVAL register. Hence the counting starts from a constant $a$ in the LDVAL.</p><p>If the input clock has a frequency $f$ , and a prescalar $p$, the timer&rsquo;s counter increments by one for every:
$$
\begin{align}
t_{inc} &= \frac{1}{f} * p = Period_{tick}\
t_{instantaneous} &= a + \Big( \frac{1}{f} * p \Big) * ticks\
\end{align}
$$
Say we need the timer to generate an event after each overflow, hence, a downcounting timer must be loaded with $LDVAL = cycles -1$,
$$
cycles = TTL-gt / Period_{tick}
$$</p><h3 id=building-a-counter-routineobsolete>Building a Counter Routine[^Obsolete]<a hidden class=anchor aria-hidden=true href=#building-a-counter-routineobsolete>#</a></h3><img src=/images/articles/projects/correlator/image-20210730094326063.png height=450px></li></ul><p>The schematic above outlines the basic proposed structure of the counting module. Whereas the calculation of the autocorrelation function is discussed in the above sections.</p><p>The counting module consists:</p><ol><li><p>A <em>TTL counter</em> (TTL-t) that receives the TTL pulses and counts them. This counter must be capable of storing counts that is comparable to the usual count rate in the experiment. Apart from that the counter must have a capture mechanism and a fast reset mechanism. The choice of this counter depends on the latency of these functions.</p><p>The range of an n-bit counter is given by: $2^{n} - 1 $. Hence a 16-bit counter has a range of 0-65,535 ($10^{4}$) and a 32-bit counter has a range of 0 - 4,294,967,295 ($~ 10^9$). Any 32-bit timer would have enough range to accommodate for any physically possible count rates. The range of a 16-bit timers (if forced to used - because of economy) can be doubled by checking the <em>overflow flag</em>. Timers set an overflow flag when they exceed their maximum value during counting, reset to zero and start counting again. Use of this method requires an additional operation of resetting the overflow flag during the next cycle of operation. This mechanism is already demonstrated in the lower half of the schematics.</p><p>Taking into account the average count rates encountered during a typical single-molecule experiments (say $10^{4}-10^{6}$ cps for FCS), we can further evaluate the problem of overflows. The typical gating time is assumed to be 100 $\mu s$. Hence, the maximum count value during a single gate interval is $\approx 1-10^{2}$. It is clear that 16-bit timers are also well equipped in terms of the range. Hence, the selection would entirely depend on speed of operations and access and not on the size of the counters, however, 32-bit timers would be preffered.</p><p>The <em>Service Time</em> of an ISR is the time taken to complete the ISR prescribed for a timer. Since, in our case, the ISR will interact with the TTL-t, the performance will also depend heavily on the Service Time of the ISR.</p><h4></h4></li><li><p>An Periodic-interrupt timer (PI-t ) will be used to trigger the opening and closing of a Counter Interval (TTL-gt) on the TTl-t. The selection of the timer will depend on the <em>Interrupt Latency</em> of the timer.</p><ul><li>The <em>Interrupt Latency</em> is the time between the raising of the interrupt by the timer module and the execution of the first instruction of the ISR. This delay is partly natural (context saving and switching, and a <code>goto/jump</code> instruction) and partly implementation dependent. The implementation dependent part is significant when multiple interrupts exist in the system within a priority hierarchy. It should also be noted that while one interrupt is running, all interrupts are disabled (The ISR is blocked within two function calls - <code>sei() and cli()</code><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>). Hence, a running interrupt may readily block the timer interrupt from executing. ==(It is however unclear to me if the wiring is done in such a way that the interrupts are handled without the use of cpu, however, the value during the capture is copied in the main memory. - EDIT: DMA operations)==</li></ul><p>For this reason, to ensure reliability, only one interrupt must be used within the system, which will be used to control the TTL-C. The <code>ISR_CI()</code>, say, will take the following form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ISR_CI</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//Capture Signal to TTL-C
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>digitalWriteFast</span><span class=p>(</span><span class=n>TTLtCapturePin</span><span class=p>,</span> <span class=n>HIGH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lowest_delay</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>digitalWriteFast</span><span class=p>(</span><span class=n>TTLtCapturePin</span><span class=p>,</span> <span class=n>LOW</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//Or an equivalent &#34;Active Low Pulse&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//DMA trigger from Input Capture register of TTL-C to software memory
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//Reset-Event on the TTL-C    
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The precise timing of the periodic interrupt service is done using an onboard clock, usually a <em>Real-time clock (RTC)</em>, Teensy 4.1 contains a 24MHz oscillator that can be used to keep track of &ldquo;real time&rdquo;. Otherwise, the Peripheral bus clock can be selected which operates at $f_{CPU}/4$.</p></li></ol><h2 id=rationale--using-pit-for-pi-t>Rationale : Using PIT for PI-t<a hidden class=anchor aria-hidden=true href=#rationale--using-pit-for-pi-t>#</a></h2><ul><li><p>Its use with DMA channels is well defined and is a common use case.</p><blockquote><p>‚Ä¢ The DMAMUX has a special mode for using this timer.</p><p>(Source: Manual, Page 77)</p><p>&ldquo;‚Üí Periodic Trigger mode :</p><p>In this mode, a DMA source may only request a DMA transfer, such as when a transmit buffer becomes empty or a receive buffer becomes full, periodically.
Configuration of the period is done in the registers of the periodic interrupt timer (PIT). This mode is available only for channels 0 to 3.&rdquo;</p><p>‚Ä¢ Also, quoting from the description of the PIT timers (Features in page 2972):</p><p>‚Ä¢ Read Page 78 onwards, section 5.4.1 for details.</p></blockquote></li><li><p>The timer is optimized for delivering periodic pulses.</p></li><li><p>This timer module has four 32-bit channels and hence offers good resolution.</p></li><li><p>The bi-modality {Stop and Run} - which is also a lack of functionality, means that the timer can be reset very fast and is ideal for our use case.</p></li><li><p>The clock source can be selected as the 150 MHz Peripheral Clock, which gives a resolution (timeperiod) of about 6.67 nanoseconds.</p></li><li><p>Cons: Module does not have a prescalar. However, for our use case, we can do without a prescalar and 2 PIT channels can be chained together for a similar arrangement.</p></li></ul><p><img alt=PI-t_schematics loading=lazy src=/images/articles/projects/correlator/PI-t_schematics.png></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The abbreviations might change for the different timer modules, however, the concepts are the same. Also, the abbreviations will be easy to understand after grasping the ones mentioned above.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><code>Arduino.h</code> defines: <code>#define interrupts() sei() ; #define noInterrupts() cli()</code>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>let isDark=document.body.className.includes("dark"),mermaidTheme=isDark?"dark":"forest",mermaidConfig={theme:"neutral",logLevel:"fatal",securityLevel:"strict",startOnLoad:!0,arrowMarkerAbsolute:!1};mermaid.initialize(mermaidConfig)</script><footer class=post-footer><ul class=post-tags><li><a href=https://yatharthb97.github.io/tags/projects/>Projects</a></li></ul><nav class=paginav><a class=prev href=https://yatharthb97.github.io/notes/biophy/urialonc2/><span class=title>¬´ Prev</span><br><span>Uri Alon Chapter 2</span>
</a><a class=next href=https://yatharthb97.github.io/projects/python-time-literals/><span class=title>Next ¬ª</span><br><span>Python Time Literals</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yatharthb97.github.io/>Yatharth Bhasin</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>